// Code generated by mrpc .\examples\basic\internal\basic.mrpc; DO NOT EDIT.

package internal

import (
	"context"

	"github.com/craiggwilson/mongo-go-server/mongo"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/bsoncodec"
	"go.mongodb.org/mongo-driver/x/bsonx/bsoncore"
)

type registryProvider interface {
	Registry(ctx context.Context) *bsoncodec.Registry
}

type AggregateCommandHandler interface {
	HandleAggregate(context.Context, *AggregateRequest) (*AggregateResponse, error)
}

type AggregateCommandHandlerFunc func(context.Context, *AggregateRequest) (*AggregateResponse, error)

func (f AggregateCommandHandlerFunc) HandleAggregate(ctx context.Context, req *AggregateRequest) (*AggregateResponse, error) {
	return f(ctx, req)
}

type AggregateRequest struct {
	DatabaseName string         `json:"-" bson:"-"`
	Pipeline     bsoncore.Array `json:"pipeline" bson:"pipeline"`
}

type AggregateResponse struct {
	OK     int32       `json:"ok" bson:"ok"`
	Cursor CursorFirst `json:"cursor" bson:"cursor"`
}

type aggregateCommandHandlerImpl struct {
	impl AggregateCommandHandler
}

func (h *aggregateCommandHandlerImpl) HandleCommand(ctx context.Context, resp mongo.CommandResponseWriter, req *mongo.CommandRequest) error {
	reg := bson.DefaultRegistry
	if rp, ok := h.impl.(registryProvider); ok {
		reg = rp.Registry(ctx)
	}

	var typedReq AggregateRequest
	if err := bson.UnmarshalWithRegistry(reg, req.Document, &typedReq); err != nil {
		return &mongo.Error{
			Code:     mongo.CodeFailedToParse,
			CodeName: mongo.CodeToName(mongo.CodeFailedToParse),
			Message:  "invalid aggregate command",
			Cause:    err,
		}
	}

	typedReq.DatabaseName = req.DatabaseName

	typedResp, err := h.impl.HandleAggregate(ctx, &typedReq)
	if err != nil {
		return err
	}
	respDoc, err := bson.MarshalWithRegistry(reg, typedResp)
	if err != nil {
		return &mongo.Error{
			Code:     mongo.CodeInternalError,
			CodeName: mongo.CodeToName(mongo.CodeInternalError),
			Message:  "failed marshaling aggregate command output",
			Cause:    err,
		}
	}

	return resp.WriteSingleDocument(respDoc)
}

func RegisterAggregateCommandHandler(mux *mongo.CommandMux, h AggregateCommandHandler) {
	mux.Handlers["aggregate"] = &aggregateCommandHandlerImpl{impl: h}
}

type BuildInfoCommandHandler interface {
	HandleBuildInfo(context.Context) (*BuildInfoResponse, error)
}

type BuildInfoCommandHandlerFunc func(context.Context) (*BuildInfoResponse, error)

func (f BuildInfoCommandHandlerFunc) HandleBuildInfo(ctx context.Context) (*BuildInfoResponse, error) {
	return f(ctx)
}

type BuildInfoResponse struct {
	OK           int32   `json:"ok" bson:"ok"`
	Version      string  `json:"version" bson:"version"`
	VersionArray []int32 `json:"versionArray" bson:"versionArray"`
}

type buildInfoCommandHandlerImpl struct {
	impl BuildInfoCommandHandler
}

func (h *buildInfoCommandHandlerImpl) HandleCommand(ctx context.Context, resp mongo.CommandResponseWriter, req *mongo.CommandRequest) error {
	reg := bson.DefaultRegistry
	if rp, ok := h.impl.(registryProvider); ok {
		reg = rp.Registry(ctx)
	}

	typedResp, err := h.impl.HandleBuildInfo(ctx)
	if err != nil {
		return err
	}
	respDoc, err := bson.MarshalWithRegistry(reg, typedResp)
	if err != nil {
		return &mongo.Error{
			Code:     mongo.CodeInternalError,
			CodeName: mongo.CodeToName(mongo.CodeInternalError),
			Message:  "failed marshaling buildInfo command output",
			Cause:    err,
		}
	}

	return resp.WriteSingleDocument(respDoc)
}

func RegisterBuildInfoCommandHandler(mux *mongo.CommandMux, h BuildInfoCommandHandler) {
	mux.Handlers["buildInfo"] = &buildInfoCommandHandlerImpl{impl: h}
	mux.Handlers["buildinfo"] = mux.Handlers["buildInfo"]
}

type GetLastErrorCommandHandler interface {
	HandleGetLastError(context.Context, *GetLastErrorRequest) (*GetLastErrorResponse, error)
}

type GetLastErrorCommandHandlerFunc func(context.Context, *GetLastErrorRequest) (*GetLastErrorResponse, error)

func (f GetLastErrorCommandHandlerFunc) HandleGetLastError(ctx context.Context, req *GetLastErrorRequest) (*GetLastErrorResponse, error) {
	return f(ctx, req)
}

type GetLastErrorRequest struct {
	ConnectionID uint64 `json:"-" bson:"-"`
}

type GetLastErrorResponse struct {
	OK           int32  `json:"ok" bson:"ok"`
	WrittenTo    string `json:"writtenTo" bson:"writtenTo"`
	Err          string `json:"err" bson:"err"`
	SyncMillis   int32  `json:"syncMillis" bson:"syncMillis"`
	N            int32  `json:"n" bson:"n"`
	ConnectionID int32  `json:"connectionID" bson:"connectionID"`
}

type getLastErrorCommandHandlerImpl struct {
	impl GetLastErrorCommandHandler
}

func (h *getLastErrorCommandHandlerImpl) HandleCommand(ctx context.Context, resp mongo.CommandResponseWriter, req *mongo.CommandRequest) error {
	reg := bson.DefaultRegistry
	if rp, ok := h.impl.(registryProvider); ok {
		reg = rp.Registry(ctx)
	}

	var typedReq GetLastErrorRequest
	if err := bson.UnmarshalWithRegistry(reg, req.Document, &typedReq); err != nil {
		return &mongo.Error{
			Code:     mongo.CodeFailedToParse,
			CodeName: mongo.CodeToName(mongo.CodeFailedToParse),
			Message:  "invalid getLastError command",
			Cause:    err,
		}
	}

	typedReq.ConnectionID = req.ConnectionID

	typedResp, err := h.impl.HandleGetLastError(ctx, &typedReq)
	if err != nil {
		return err
	}
	respDoc, err := bson.MarshalWithRegistry(reg, typedResp)
	if err != nil {
		return &mongo.Error{
			Code:     mongo.CodeInternalError,
			CodeName: mongo.CodeToName(mongo.CodeInternalError),
			Message:  "failed marshaling getLastError command output",
			Cause:    err,
		}
	}

	return resp.WriteSingleDocument(respDoc)
}

func RegisterGetLastErrorCommandHandler(mux *mongo.CommandMux, h GetLastErrorCommandHandler) {
	mux.Handlers["getLastError"] = &getLastErrorCommandHandlerImpl{impl: h}
}

type IsMasterCommandHandler interface {
	HandleIsMaster(context.Context, *IsMasterRequest) (*IsMasterResponse, error)
}

type IsMasterCommandHandlerFunc func(context.Context, *IsMasterRequest) (*IsMasterResponse, error)

func (f IsMasterCommandHandlerFunc) HandleIsMaster(ctx context.Context, req *IsMasterRequest) (*IsMasterResponse, error) {
	return f(ctx, req)
}

type IsMasterRequest struct {
	Compression []string `json:"compression" bson:"compression"`
}

type IsMasterResponse struct {
	OK                           int32    `json:"ok" bson:"ok"`
	Ismaster                     bool     `json:"ismaster" bson:"ismaster"`
	MaxBsonObjectSize            int32    `json:"maxBsonObjectSize" bson:"maxBsonObjectSize"`
	MaxMessageSizeBytes          int32    `json:"maxMessageSizeBytes" bson:"maxMessageSizeBytes"`
	MaxWriteBatchSize            int32    `json:"maxWriteBatchSize" bson:"maxWriteBatchSize"`
	LogicalSessionTimeoutMinutes int32    `json:"logicalSessionTimeoutMinutes" bson:"logicalSessionTimeoutMinutes"`
	MinWireVersion               int32    `json:"minWireVersion" bson:"minWireVersion"`
	MaxWireVersion               int32    `json:"maxWireVersion" bson:"maxWireVersion"`
	ReadOnly                     bool     `json:"readOnly" bson:"readOnly"`
	Compression                  []string `json:"compression" bson:"compression"`
}

type isMasterCommandHandlerImpl struct {
	impl IsMasterCommandHandler
}

func (h *isMasterCommandHandlerImpl) HandleCommand(ctx context.Context, resp mongo.CommandResponseWriter, req *mongo.CommandRequest) error {
	reg := bson.DefaultRegistry
	if rp, ok := h.impl.(registryProvider); ok {
		reg = rp.Registry(ctx)
	}

	var typedReq IsMasterRequest
	if err := bson.UnmarshalWithRegistry(reg, req.Document, &typedReq); err != nil {
		return &mongo.Error{
			Code:     mongo.CodeFailedToParse,
			CodeName: mongo.CodeToName(mongo.CodeFailedToParse),
			Message:  "invalid isMaster command",
			Cause:    err,
		}
	}

	typedResp, err := h.impl.HandleIsMaster(ctx, &typedReq)
	if err != nil {
		return err
	}
	respDoc, err := bson.MarshalWithRegistry(reg, typedResp)
	if err != nil {
		return &mongo.Error{
			Code:     mongo.CodeInternalError,
			CodeName: mongo.CodeToName(mongo.CodeInternalError),
			Message:  "failed marshaling isMaster command output",
			Cause:    err,
		}
	}

	return resp.WriteSingleDocument(respDoc)
}

func RegisterIsMasterCommandHandler(mux *mongo.CommandMux, h IsMasterCommandHandler) {
	mux.Handlers["isMaster"] = &isMasterCommandHandlerImpl{impl: h}
	mux.Handlers["ismaster"] = mux.Handlers["isMaster"]
}

type BasicService interface {
	AggregateCommandHandler
	BuildInfoCommandHandler
	GetLastErrorCommandHandler
	IsMasterCommandHandler
}

func RegisterBasicService(mux *mongo.CommandMux, svc BasicService) {
	RegisterAggregateCommandHandler(mux, svc)
	RegisterBuildInfoCommandHandler(mux, svc)
	RegisterGetLastErrorCommandHandler(mux, svc)
	RegisterIsMasterCommandHandler(mux, svc)
}

type CursorFirst struct {
	FirstBatch bsoncore.Array `json:"firstBatch" bson:"firstBatch"`
	ID         int64          `json:"id" bson:"id"`
	NS         string         `json:"ns" bson:"ns"`
}

type CursorNext struct {
	NextBatch bsoncore.Array `json:"nextBatch" bson:"nextBatch"`
	ID        int64          `json:"id" bson:"id"`
	NS        string         `json:"ns" bson:"ns"`
}
